Происходит активное связывание nvim и lua, конфиги уже пишутся в основном под lua, да и вообще похоже что с 0.6 версии не получится использовать старые конфиги. Похоже, придется изучить, как настраивать конфиг в таких условиях.


Первичная инструкция - на страничке https://habr.com/ru/post/586808/, 
и из комментов:

Я тоже прошел этим путем и переписал свой конфиг на lua.
Полезные ссылки, которые мне помогли при этом:
1) Гайд на русском языке (есть и английский там же) о том как переехать https://github.com/kuator/nvim-lua-guide-ru
2) Удобный кик-старт. Да, там все в одном файле, но зато можно сразу запустить и разобраться что к чему https://github.com/nvim-lua/kickstart.nvim
3) Толковый видео ролик на эту тему: https://www.youtube.com/watch?v=ppMX4LHIuy4
Всего 10 минут. Очень понятно объясняет.
4) Я сторонник с нуля собирать, но полезно смотреть за чужим опытом. Отличные готовые сборки:
https://github.com/NvChad/NvChad
https://github.com/LunarVim/LunarVim

сначала поставим собственно lua
	
	sudo apt install lua5.4

Если нужно проверить работу, запускается просто
	
	lua
	lua test.lua

Более подробно по языку - в его директории.

Требует nvim 0.7.0, иду на страничку https://github.com/neovim/neovim/releases/tag/v0.7.0, загружаю сюда пакет и устанавливаю. 
	загружаю nvim-linux64.deb
	удаляю старый sudo apt remove neovim
	устанавливаю sudo apt install ./nvim-linux64.deb
	запускаю nvim


Предположил, что все проблемы из-за отсутствия менеджера плагинов packer.nvim, гитхаб https://github.com/wbthomason/packer.nvim:

    git clone --depth 1 https://github.com/wbthomason/packer.nvim\
 ~/.local/share/nvim/site/pack/packer/start/packer.nvim
 
Это распаковало данный менеджер плагинов в директорию .local/share/nvim/site/pack/packer/start/packer.nvim. Как то ничего не произошло. Плюнул на все что было, удалил все из ~/.config/nvim, вставил новый одиночный файл init.lua со странички https://itchef.ru/articles/84717/, куча ошибок, но как минимиум заработала подсветка синтаксиса Lua.


Принял решение следовать за Rilkener в статье "Как я переписывал vim конфиг в init.lua", по адресу https://habr.com/ru/post/586808/. 

Соответственно, в директории ~/.config/nvim создал новую структуру:

	/nvim
	|-------/lua
	|-------|-------keymaps.lua
	|-------|-------plugins.lua
	|-------|-------settings.lua
	|-------init.lua
		

ВЫЯСНИЛ, ЧТО НУЖНО БЫЛО УСТАНОВИТЬ ВСЕ ПЛАГИНЫ С ПОМОЩЬЮ КОМАНДЫ PackerInstall, эта команда проверяерт все конфиги, находит там упоминания плагинов и устанавливает их.

выяснил, что даже в этом случае, куча ошибок в подгрузке плагинов, то есть команды require('keypmaps'), require('settings') работают, а команда require('plugins') нет. Нужно что то думать.

выяснил, что была просто опечатка в скопированном тексте, не хватало буквы u в какой то строчке. повторно запустил PackerInstall, доустановились еще пять или шесть плагинов.

понял, что не хватает самого сервера lsp, увидел команду LspInstall, там был выбор какие сервера можно загрузить, загрузил pyright:
    
               Installed servers (1)                                                                          │
 17     def │    ◍ pyright (python)                                                                           │
 16         │      version   1.1.248                                                                          │
 15         │      installed 22 мая 2022 16:45                                                                │
 14         │      path      ~/.local/share/nvim/lsp_servers/python                                           │
 13     def │      homepage  https://github.com/microsoft/pyright 


решил установить lsp под lua
               Installed servers (2)                                                                          │
  8         │    ◍ sumneko_lua (lua)                                                                          │           
~           │      version   v3.2.3                                                                           │
~           │      installed 22 мая 2022 16:57                                                                │
~           │      path      ~/.local/share/nvim/lsp_servers/sumneko_lua                                      │
~           │      homepage  https://github.com/sumneko/lua-language-server                                   │
~           │                                                                 



Сразу же нашел ошибку - был пустой пробел в конфиге init.lua после первой команды.
Нашел еще ошибки в конфигах - вместо фигурных скобок в функцию requre(чтототам).setup{} были вставлены круглые.

выглядит так, что просто нужно было найти пару ошибок, поставить lsp для lua и радоваться. Конфиг Rilkener вполне работает.

################################################################################

повторно, описание схемы установки плагинов. Какой то очень сильно жрет своп-файл, за час работы занимает под 6 гигов свопа. Поэтому удаляю все плагины. кроме цветовй схемы и самого Packer так:

1. Закомментировал все подключения use в файле plugins.lua, кроме указанных двух пакетов.

2. Сохранил файл, применил его настройки через :so %, запустил команду PackerCleane - она есть в автодополнениях. 

3. Все плагины были удалены. Параллельно сбились настройки и остальных файлов - settings.lua и keymaps.lua.

4. Применяю настроки всех файлов с помощью :so % - то есть для каждого файла. Сначала для keympas.lua - с ним никаких проблем, потом для plugins.lua - там тоже нет проблем, потом для settings.lua. Хотя в принципе достаточно и только для одного файла применать - для init.lua.

5. В файле settings требуются плагины lsp-сервера (они кстати похоже не удалятся по команде PackerCleane), поэтому и начинаю по одному раскомментировать их, сохранять файл plugins.lua, применять его настройки через :so % и ставить с помощью комнады PackerInstall. В порядке очереди ошибок, возникающих после каждого применения команды :so % для файла settings.lua. То есть установил плагин, применил настройки settings.lua, выяснил что еще какого то не хватает, перешел к следующему в списке.

6. Так делаю до тех пор, пока не будет настроена минимальная конфигурация с минимальным количеством плагинов. Файл settigs.lua требует просто какой то плагин cmp, но такого нет в списке плагинов в файле plugins.lua, поэтому буду проверять похожие.  

7. установил nvim-cmp и cmp-luasnip, ошибки того вида, что необходим какой то файл ушли, осталась одна ошибка - sources[nubmer].opts is deprecated, мол, используйте sources[nubmer].option. А в каком файле эта ошибка, непонятно, возможно в каком то плагине. Начинаю искать эту ошибку.

8. Нашел место ошибки и исправил, это сам файл settings.lua, в точке подгрузки файла require 'cmp', в установке загруженного файла параметра sources, в таблице было слово opts. Заменил его на то, которое требовал - на option. Вроде больше не требует ничего.

9. Никак не могу разобраться, как пользоваться автокомплитом. Есть вариант поискать для этого плагина инфу в интернете, в коде плагина (нужно где то в нем найти файл cmp.lua - это и будет знаком, что это нужный нам плагин), еще есть вариант скопировать из похожей части старого файла init.vim, который достался мне от Голобурдина. 
Сначала просто перечитаю эти два одинаковых участка кода.
Выяснил, что для навигации по предложенным вариантам можно использовать Ctrl-p, Ctrl-n, выбирать вариант соответственно Enter. То есть уже прямо сейчас, все вполне работает и функционально.

8. Скопировал минимально функциональный, но работоспособный конфиг. В нем есть поддержка lsp, автодополнения, немного другие настройки клавиш, но они даже немного получше чем были. В частности переключения буферов на Tab, переключение языка на Alt-Shift, что нибудь еще.

9. Мне нужно настроить автокомплит так, чтобы он не был включен по умолчанию. Для этого скопирую строки настроек из файла Голобурдина в settings.lua:
    -- отключил автокомплит по умолчанию
  completion = {
    autocomplete = false
  },
    -- конец настроек автокомплита по умолчанию

10. Но включать то мне его нужно, поэтому нужно как то размапить. Просто скопирую настройку маппинга из файла Голобурдина в файл settings.lua:
    -- новый вариант маппинга клавиатуры, из файла Голобурдина
  mapping = {
    ['<C-p>'] = cmp.mapping.select_prev_item(),
    ['<C-n>'] = cmp.mapping.select_next_item(),
    ['<C-d>'] = cmp.mapping.scroll_docs(-4),
    ['<C-f>'] = cmp.mapping.scroll_docs(4),
    ['<C-Space>'] = cmp.mapping.complete(),
    ['<C-e>'] = cmp.mapping.close(),
    ['<CR>'] = cmp.mapping.confirm {
      behavior = cmp.ConfirmBehavior.Replace,
      select = true,
    },
    ['<Tab>'] = function(fallback)
      if vim.fn.pumvisible() == 1 then
        vim.fn.feedkeys(vim.api.nvim_replace_termcodes('<C-n>', true, true, true), 'n')
      elseif luasnip.expand_or_jumpable() then
        vim.fn.feedkeys(vim.api.nvim_replace_termcodes('<Plug>luasnip-expand-or-jump', true, true, true), '')
      else
        fallback()
      end
    end,
    ['<S-Tab>'] = function(fallback)
      if vim.fn.pumvisible() == 1 then
        vim.fn.feedkeys(vim.api.nvim_replace_termcodes('<C-p>', true, true, true), 'n')
      elseif luasnip.jumpable(-1) then
        vim.fn.feedkeys(vim.api.nvim_replace_termcodes('<Plug>luasnip-jump-prev', true, true, true), '')
      else
        fallback()
      end
    end,
  },
  -- Конец маппинга из файла Голобурдина

11. Отлично, теперь можно включать автокомплит при необходимости старой командой Ctrl-Space. Хотя почему то не работают команды Tab, Shift-Tab - возможно потому что где то в другом месте - ага, в файле keymaps.lua на Tab повешено переключение буферов в режиме команд (а тут у нас режим вставки, поэтому не понятно, возможно нужно настроить еще как то но это не очень важно, достаточно навигации по Ctrl-n, Ctrl-p).

UPD. Решил оставить включенным автокомплит.

12. Хочу попробовать добавить функционал из старого файла Голобурдина - про go_to_definition, go_to_еще_куда_то_там, просмотр инфы по функции по нажатию на K и т.д. Читаю, разбираюсь как скопировать.

Так, ага, используется плагин neovim/nvim-lspconfig, смотрю, есть ли такой среди уже установленных плагинов в файле plugins.lua. Отлично, он уже есть, надо посмотреть, где в файле settings.py он уже использовался.   

просто скопировал весь блок, внес в список используемых lsp-серверов sumneko-lua
Постепенно понял, что это все не нужно, удалил вставленный текст из settings.lua, вместо этого вставил немного обработанные команды в файл keymaps.lua. 

Файл keymaps.lua по сути содержит набор команд, которые выполнятся в командной строке Неовима после набора соответствующего сочетания клавиш. 

Вставил следующий текст.
    -- Набор сочетаний клавиш для go_to_definiton, скопированы из файла Голобурдина
    map('n', 'gD', '<cmd>lua vim.lsp.buf.declaration()<CR>', default_opts)
    map('n', 'gd', '<cmd>lua vim.lsp.buf.definition()<CR>', default_opts)
    map('n', 'K', '<cmd>lua vim.lsp.buf.hover()<CR>', default_opts)
    map('n', 'gi', '<cmd>lua vim.lsp.buf.implementation()<CR>', default_opts)
    map('n', '<C-k>', '<cmd>lua vim.lsp.buf.signature_help()<CR>', default_opts)
    map('n', '<space>wa', '<cmd>lua vim.lsp.buf.add_workspace_folder()<CR>', default_opts)
    map('n', '<space>wr', '<cmd>lua vim.lsp.buf.remove_workspace_folder()<CR>', default_opts)
    map('n', '<space>wl', '<cmd>lua print(vim.inspect(vim.lsp.buf.list_workspace_folders)))<CR>', default_opts)
    map('n', '<space>D', '<cmd>lua vim.lsp.buf.type_definition()<CR>', default_opts)
    map('n', '<space>rn', '<cmd>lua vim.lsp.buf.rename()<CR>', default_opts)
    map('n', '<space>ca', '<cmd>lua vim.lsp.buf.code_action()<CR>', default_opts)
    map('n', 'gr', '<cmd>lua vim.lsp.buf.references()<CR>', default_opts)
    map('n', '<space>e', '<cmd>lua vim.lsp.diagnostic.show_line_diagnostics()<CR>', default_opts)
    map('n', '[d', '<cmd>lua vim.lsp.diagnostic.goto_prev()<CR>', default_opts)
    map('n', ']d', '<cmd>lua vim.lsp.diagnostic.goto_next()<CR>', default_opts)
    map('n', '<space>q', '<cmd>lua vim.lsp.diagnostic.set_loclist()<CR>', default_opts)
    map('n', '<space>f', '<cmd>lua vim.lsp.buf.formatting()<CR>', default_opts)
    -- this is good!
По сути, map - это краткое название функции  local map = vim.api.nvim_set_keymap, для удобства. И мы отправляем в эту функцию какие то сочетания клавиш. ПРосто в файле Голобурдина не было этого сокращения имени функции. Параметр default_opts - не знаю, что такое, но у подобных функций выше был именно он, поэтому изменил на это.

Оказалось, что не работает, без скопированного кода в settings.lua. Копирую обратно.
Оказалось что и без этого работает, просто гребаный свопфайл лезет под руку. Удалил из settings.lua все что туда навставлял (имею в виду блок кода для возможности go_to_definition, K и т.д.), оставил в keymaps.lua все эти команды-сокращения. В принципе работоспособно.

13. добавил в файл settings.lua строчку, чтобы не было своп-файла. 
    opt.swapfile = false                -- задолбал гребаный своп-файл каждый раз

14. Сохранил кофигурацию, как минимально имеющую плагины, но с плюшками типа go_to_definition, K, настроенный автокомплит, тема grouvbox. 

15. Теперь можно начать добавлять плагины. Начну с плагина, который позволит на русской раскладке вводить английские команды.
    -- Даже если включена русская раскладка vim команды будут работать
    use 'powerman/vim-plugin-ruscmd'
    :w
    F3
    :PackerInstall
    F3
Еще нужно добавить в keymaps.lua сочетание ОО для перехода в командный режим
    map('i', 'ОО', '<Esc>', {noremap = true})
Великолепно, работает все.

16. Теперь мне нужно настроить работу с буферами. То есть чтобы по Ctrl-p, Ctrl-a открывался список открытых буферов для удобной навигации.
    -- Замена fzf и ack
    use { 'nvim-telescope/telescope.nvim',
    requires = { {'nvim-lua/plenary.nvim'} },
    config = function() require'telescope'.setup{} end, }

17. Пробую добавить плагин, чтобы очень быстро все закомментировать по команде. По умолчанию написано, что это выполняется сочетанием gc, и это действительно так.

     -- Комментирует по gc все, вне зависимости от языка программирования
     use { 'numToStr/Comment.nvim',
     config = function() require('Comment').setup{} end }

нужно добавить в конец settings.lua команду для запуска этого плагина
Работает, но если пытаться что нибудь закомментировать в .txt файле, то вылетает ошибка.

18. Хочу себе красивую строчку-статус.

    --- Информационная строка внизу
    use {
      'nvim-lualine/lualine.nvim',
      requires = {'kyazdani42/nvim-web-devicons', opt = true},
      config = function() require('lualine').setup{} end,
    }
По умолчанию ничего не происходит.

Полазил по гитхабу красивой строчки lualine, нашел образцы. Решил скачать один - evil-lualine и второй - slanted-gaps. Вставлю в директорию, потом эту директорию помещу где нибудь в очередном сохранении настроек.

Нашел команду запуска строчки - require('lualine').setup(). Запустил в командной строке - строчка появилась, но нет красивых картинок, вместо них - странные крякозябры. Ну и строчка по умолчанию вполне функциональная, не буду ставить другую.

Ищу что сделать, чтобы не было крякозябр. Вроде как для работы не этого плагина, а другого, нужны специальные шрифты www.nerdfonts.com - сайт с такими. Надо разобраться как их поставить на комп. На гитхабе lualine также есть указание - You'll also need to have a patched font if you want icons. 

пробую скачать с nerdfonts.com, там же нашел в самом низу инструкцию к установке шрифта - 		
    ./install.sh <FontName>

понял, что оно того не стоит, на страничке Хабра, у Rilkener'a нашел ссылку на уже готовый обычный шрифт - Literation Mono Nerd Font Complete Mono.ttf, по ссылке https://github.com/ryanoasis/nerd-fonts/blob/master/patched-fonts/LiberationMono/complete/Literation%20Mono%20Nerd%20Font%20Complete%20Mono.ttf. Скачал, стандартно установил, теперь строка вполне великолепная. Сам шрифт лежит тут рядом. 

Нужно разобраться, как автостартом запускать эту команду - require('lualine').setup().

Добавил в самый низ файла settings.lua строку:
    -- Запуск красивой строки состояния при начале работы
    cmd [[lua require('lualine').setup() ]]

Теперь она запускается всегда. 


19. Надо разобраться как работать с Telescope - полезная штука должна быть но нифига не работает. 
разобрался - нужно было установить утилиту ripgrep



Попутно подключил поддержку мыши - в файле settings.lua внес строку
    opt.mouse = 'a'                     -- поддержка мыши

Попутно выяснил сочетание клавиш Ctrl-- уменьшает размер шрифта, Ctrl-0 возвращает размер шрифта. Удобно для чтения длинных строчек ошибок линтера.

Попутно выяснил, что есть возможность обновлять плагины через команду PackerSync. Как минимум один плагин обновился. Интересно, какие еще  команды есть в Packer.



Выяснил, что куча потреблямой памяти при простом открытие файлов .lua не происходит, но рост занимаемой оперативки начинатся в момент выполнения команды :so %, Может быть это както связано с хранением изменений и файлов для отката изменений. Точно связано

Выглядит так, что память пропадает после установки и применения новых плагинов. Нужно перезагружать neovim после установки новых, чтобы сбрость загрузку оперативки и свопа. 

Нужно просто каждый раз после установки одного плагина, перезагружать Неовим.  

Очень важно, после последнего F3 как можно быстрее выйти из Неовима. Иначе разгон и занятие всей оперативки.

UPD. После очередного исправления конфига проблема пропала.
UPD. Снова появилась.

UPD. чтобы работал telescope, нужна утилита ripgrep - быстрый и современный аналог grep. Пакет для установки так и называется - ripgrep.

для запуска проверки на орфографию требуется скачать файл с проверочными данными, но это происходит автоматически, после запуска проверки орфографии.

Как выяснилось, почему то не работают сочетания клавиш Shift+F<n> - просто не реагирует ничего. Заменил в настройках клавишу Shift на <.

Кроме того, нельзя подключать ничего на клавиши  F1 и F11 - на одной справка, на другой - полноэкранный режим консоли.

Почему то приходится укзывать вариант команды, начинающийся с <, и для русской раскладки и для английской.

Выяснил, в файле keymaps.lua, чтобы не было переноса курсора на один пробел после какой нибудь команды, нужно убрать пробел между забинженным вызовом двух команд, например, переход на следующую строку с последующей центровкой нажатием на клавиши gj. Последние параметры оказались важны оба:
    map('n', 'gj', 'jzz', {noremap=true, silent=true})


В том же файле, если нужно сочетание из двух клавиш в верхнем регистре, то можно так и писать их в верхнем регистре, редактор поймет, причем для обоих режимов. А если это команда из одной большой буквы, то можно писать и просто одной буквой в верхнем регистре, а можно и указывать через префикс, например "S-l" - это в моем конфиге перелистывать на одну страницу вниз + центровка, а команда JL - это указание слить строки, вместо старой команды J.

Просмотр всех ошибок LSP -сервера в конкретной строке - Space+e

Чтобы заработал плагин менеджера классов и функций похоже требуется установить утилиту ctags, которая собирает информацию об всех именах и позициях переменных, функций, классов. Для nvim это программка Exuberant Ctags, пакет называется exuberant-ctags, устновился без проблем, плагин тоже установился, теперь можно по F8 вызывать дерево функций, хотя оно слегка неудобно - переход на один из элементов переводит курсор обратно в основное окно, приходится постоянно тянуться туда-сюда. Возможно, просто нужно удобно настроить навигацию по окнам.

можно читать help по плагинам с помощью команды :help <plugin_name>, например :help treesitter


неожиданно выяснилось, что плагин lua-cmp может выполнять автоимпорт просто по имени. Для этого достаточно начать использовать имя класса, функции или переменной, запустить автодополнение имени из определений - Ctrl-Space, и одновременно вместе с вариантами автодополнений будет показано, возможно или нет выполнить автоимпорт. Причем, если имя находится в разных модулях, можно выбирать из какого будет выполнен импорт.

В копилку про автоиморт:

Редактор для редактирования файлов проекта следует запускать, также находясь в виртуальном окружении - чтобы не было проблем с импортами библиотек (LSP может не увидеть библиотеку DRF).

Нужно разобраться, как устанавливать рабочий каталог в проекте, возможно LSP из-за этого слегка тупит. Ага, каждый файл считает, что он нахоится в рабочей директории и если через Space-w-a открыть путь к ней и отредактировать на путь к директории проекта, частично налаживается (линтер налаживается, а вот LSP - нет, по прежнему не хочет импортировать при автодополнении).

Как выяснилось, проблемы с импортом могут возникать, если в проекте есть неверно определенные слова. Например, в конспекте ошибочно написал ResponseI (вместо Response) и LSP подтгягивал именно это слово, игнорируя это слово в модуле rest_framework.response и соотоветсвенно, не импортируя.

Очень сильно похоже, что для автоимпорта какой либо функции, ее хотя бы раз нужно импортировать в проекте вручную... Что то странное. Например, функция model_to_dict из django.forms.models не автоимпортировалась до того, пока вручную один раз не импортировил и сохранил файл.


upd. Теперь переход на одну реальную строку по gj также и в режиме выделения. Стало удобнее.


Выяснил, что делать с ошибкой вида "cannot access member objects for type" при работе с менеджером записей моделей Django - нужен пакет из pip с названием django-stubs, установленный в виртуальное окружение. По словам со SO это проблема с метаклассами в LSP-сервере или что то такое.
    pip install django-stubs
